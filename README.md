# SimulationSandbox

A class library that allows various types of simulations to be performed and connected through algebraic expressions.

## Overview

The original inspiration for this project came from the [Math.NET Symbolics](https://symbolics.mathdotnet.com/) computer algebra library. This library provides a way to evaluate formulas written in a standard format. For example, you can provide a string such as "1/(1 + a)", specify that the value of "a" is 5, and evaluate the string the obtain a result of ~0.167.

The purpose of my library is to extend this functionality by allowing the value of "a" to be generated using a variety of methods. The goal is to provide an easy, flexible way to simulate different types of events using the same building blocks. As long as the outcome can be expressed with an algebraic expression, it can be evaluated by generating values for the underlying parameters. Furthermore, simulations can also be used as parameters for other simulations, essentially allowing you to construct a system of equations to define complex problems.

## Simulation Types

- Standard Simulation
- Dependent Simulation
- Sensitivity Simulation
- Exhaustive Sensitivity Simulation
- Qualitative Simulation
- Binomial Tree Simulation
- Binomial Option Pricing Simulation

#### Standard Simulation

This serves as the building block for most other types of simulations. To create a simulation, you must provide an expression and a collection of parameters. For example:

    string expression = "twentysided";
    
    IParameter[] parameters = new IParameter[]
    {
        new DistributionParameter("twentysided", new DiscreteUniform(1, 20))
    };

    Simulation simulation = new Simulation(expression, parameters);

The above is a simple example of how expressions and parameters interact to create a simulation. The expression tells the simulation that we wish to evaluate the result of one variable named "twentysided". For every variable in the expression, we must define how the value of that variable will be determined. In this case, we have defined the "twentysided" variable to be a discrete uniform distribution from 1 to 20 -- essentially, we are going to roll a twenty-sided die and return the value.

Simulations can become far more complicated. Let's take a look at something that is a bit more useful:

    string expression = "Rf + B * (Rm - Rf)";
  
    IParameter[] parameters = new IParameter[]
    {
        new DistributionParameter("B", new Normal(1, 0.1)),
        new ConstantParameter("Rf", 0.02),
        new DistributionParameter("Rm", new Normal(0.08, 0.035))
    };
  
    Simulation simulation = new Simulation(expression, parameters);

The expression here represents the Capital Asset Pricing Model (CAPM). The inputs are the risk-free rate (Rm), Beta (B), and the expected market return (Rm). For this simulation, we have decided to hold our risk-free rate constant at 2% and fluctuate our Beta and market return using normal distributions. Presumably, we would do something like this if we were not sure what the exact values should be, but wanted to get an idea of what the range of expected returns looks like for our parameter estimates. A simulation like this would be run multiple times to generate a result set containing summary statistics such as min, max, mean, median, standard deviation, etc..

The types of parameters that can be used in a simulation will be detailed below. The test project also serves as a good example of how to create simulations and use the various parameters. However, I will highlight one more feature in this overview -- the ability to include simulations as parameters for other simulations. First, I will show how this is represented conceptually with expressions:

    x + y + z
    
    x = 10 * a + b
    y = (c - d) / 5
    z = ln(n^(1/2))

The ultimate expression we wish to evaluate is x + y + z. As shown by the full equations, x, y, and z are all stand-alone expressions that need to be evaluated in order to produce a value from our final expression. Instead of writing one complex expression, we can use multiple simulations to break it into pieces that can be evaluated indepedently. One thing that is not obvious from this example is that the return value produce by a simulation parameter does not have to be the number generated by evaluating of the formula, but can be a summary statistic instead. In this case, we could have defined a and b in equation x to be distribution parameters, run simulation x 100 times per evaluation of the main expression, and taken the maximum value from each set of 100 inner simulations. Perhaps I will replace this with a less arbitrary example in the future, but the point I am trying to convey is that being able to use simulations inside of simulations is useful both for breaking complex problems into smaller pieces and for providing enhanced functionality that would be difficult to replicate otherwise. This enhanced functionality will be shown in more detail in the sensitivity simulation section.

#### Dependent Simulation

A dependent simulation is a special type of simulation that occurs over n numbers of periods, where each periods value depends on the value of the previous period. The thought process behind this, and the example that I am about to show, is providing a way to generate a random walk, such as the daily price of a stock over the course of one year.

    string expression = "value * (1 + dailyChange)";
    DistributionParameter normal = new DistributionParameter("dailyChange", new Normal(0.01, 0.0025));    
    DependentSimulation simulation = new DependentSimulation(100, expression, normal);

There are a few key things to note here. The expression passed to the simulation constructor must contain a variable named "value". Additionally, only one parameter can be provided in the constructor. This parameter is called the "change parameter" and should be used in the expression to determine how the value will change from period to period. The "value" variable will be replaced each period with the result of evaluating the expression for the previous period. I may consider allowing multiple change parameter inputs in the future, but keep in mind that the change parameter can be a simulation parameter with an unlimited number of other parameters, so the constraint is generally not too much of a limiting factor. 

#### Sensitivity Simulation

This type of simulation is designed to assess the impact of changing one or more variables while holding the rest of the expression constant (constant as in the method in which the values are generated does not change, even though the actual values can still fluctuate). To best illustrate this, I will provide an alternative example of the CAPM expression discussed earlier.

    string expression = "Rf + B * (Rm - Rf)";
    
    IParameter[] parameters = new IParameter[]
    {
        new PrecomputedParameter("B", new FloatingPoint[] { 0.5, 1.0, 1.5 }),
        new DistributionParameter("Rm", new Normal(0.08, 0.035)),
        new PrecomputedParameter("Rf", new FloatingPoint[] { 0.015, 0.02, 0.025 })
    }
        
    Simulation simulation = new Simulation(expression, parameters);
    SensitivitySimulation sensitivity = new SensitivitySimulation(simulation);

There are two major differences from above. First, the parameters for B and Rf are using a type of parameter called a PrecomputeredParameter. In order to construct a sensitivity simulation, one more more PrecomputedParameters must be used. Second, the SensivitySimulation is constructed by providing it with a simulation that was created with the PrecomputedParameters. 

The simulation will be performed as follows: PrecomputedParameters will be divided into sets, corresponding to the order in which the values were provided. In this case, we would have three sets of parameters for B and Rf, (0.5, 0.015), (1.0, 0.02), and (1.5, 0.025). For each set of parameters, n number of simulations will be performed based on the expression provided, using the PrecomputedParameter values for every simulation and generating a new Rm value each time from the normal distribution. The results of the sensitivity simulation will be a collection of results from the underlying simulations and summary statistics identifying which combination of precomputed values produced the best and worst possible outcomes.

#### Exhaustive Sensitivity Simulation

This is very similar to the sensitivity simulation described above, but with one caveat. In the prior example, sets of PrecomputedParameters were generated based on the order in which the values were provided. For the exhaustive variant of the simulation, all possible combinations of the PrecomputedParameters will be tested. This means that the above example would return 9 result sets instead of three. Obviously, this can lead to a drastic increase in computation time, so this has been broken into a seperate class so the user can choose when to use this version. Additionally, the exhaustive sensitivity simulation provides a multi-threaded version of the Simulate function to speed up computation when resources are available. Neither version of the sensivity simulation can be used as a simulation parameter, although it seems like it would be feasible to implement if there was a need for this in the future.

#### Qualitative Simulation

Qualitative simulations are designed to provide a non-numeric result to a quantitative simulation. A better way to phrase this might be to say that this type of simulation is meant to represent a decision or classification made based on the observation of the underlying data. To illustrate this, I will use what I hope is a more interesting example than some of the ones I have previously provided.

    QualitativeParameter param = new QualitativeParameter("arrowkey",
                                                          new QualitativeOutcome("left", 0.25),
                                                          new QualitativeOutcome("right", 0.25),
                                                          new QualitativeOutcome("up", 0.25),
                                                          new QualitativeOutcome("down", 0.25));
                                                          
    QualitativeSimulation simulation = new QualitativeSimulation(param);
    QualitativeSimulationResults results = simulation.Simulate(_numberOfSimulations);

Imagine you are creating a computer game where the AI opponent will randomly move in one direction each turn. To represent this movement, I have defined a set of outcomes called "arrowkey" where the AI is equally likely to move in any direction. When the Simulate function is called, a result set will be returned that contains the next n moves that the AI will make. The outcomes can be defined as anything you would like, so long as the cumulative probability of all outcomes adds up to 100%.

While the above example serves as a decision, qualitative simulations can also produce classifications. For example:

    QualitativeConditionalParameter param = new QualitativeConditionalParameter(
                                            "upordown",
                                            new DistributionParameter("normal", new Normal(1, 0.1)),
                                            "flat",
                                            new QualitativeConditionalOutcome(ComparisonOperator.GreaterThan, 1, "up"),
                                            new QualitativeConditionalOutcome(ComparisonOperator.LessThan, 1, "down"));

    QualitativeSimulation simulation = new QualitativeSimulation(param);
    QualitativeSimulationResults results = simulation.Simulate(_numberOfSimulations);

The above simulation will generate n values from a normal distribution and classify each value as "up", "down", or "flat" depending on whether how the observed value compares to the conditional outcome value (1, in this case). The above simulation could be used to answer the questions, "what percentage of the time do I expected the stock market to rise or fall on a given day?".

Similar to the first example, qualitative simulations can be also be used to simulate the occurence of discrete events without having to explicity define the probability of each outcome. 

    QualitativeRandomBagParameter bag = new QualitativeRandomBagParameter("bag", RandomBagReplacement.AfterEachPick);
    bag.Add("rare item", 100);
    bag.Add("uncommon item", 300);
    bag.Add("common item", 600);

    QualitativeSimulation simulation = new QualitativeSimulation(bag);
    QualitativeSimulationResults results = simulation.Simulate(_numberOfSimulations);

The above examples serves as a simplified loot table for killing an NPC in a video game. Upon dying, the NPC will drop one item. To determine what item the NPC drops, we have created a theoretical bag containing all possible items. We then added a specific number of each item to the bag, and upon dying, we will reach into the bag and pull out one of these items to give to the player. Imagery aside, what this actually does is generate a simulation identical to the first example in this section, but leaves the hardwork of computing the probabilities to the computer. Additionally, it allows for shifting of probabilities over time (i.e. dependent events) if the "WhenEmpty" or "Never" replacement options are specified. Another simple example of how this could be used is to pick names out of a hat, where every name is added to the hat one time and the simulation results contain the order in which the names were chosen.

Although qualitative simulations can stand on their own, they can be used as parameters for standard simulations when wrapped inside a qualitative interpretation parameter. The jist of this is that we can provide an "interpretation dictionary" to decide how to transform a string back into a number used in the evaluation of our expression. A practical example might be creating a simulation where we will make a "go/no go" decision and then multiple the remainder of the expression by 1 for "go" or 0 for no "go" to compute only the outcomes where we chose to proceed.

#### Binomial Tree Simulation

This is a very specific type of simulation designed to produce a node tree encompassing n periods based on the volatility parameter and up probability provided. By itself, this simulation is not particularly useful, but it served as the foundation for me to create the option pricing version of the simulation.

#### Binomial Option Pricing Simulation

As this is a specialized finance function, I will not spend too much time on the details. Essentially, this type of simulation is used to compute the price of a call or put option using the [binomial options pricing model](https://en.wikipedia.org/wiki/Binomial_options_pricing_model). I have provided a class for specifying the details of the option to be valued. I am reasonably confident in the basic implementation, but do not advise using this for the purpose of making actual investments. If that is your goal, I would advise hiring me full-time and I will be happy to provide a more robust version of this pricing model, among many other valuable contributions.

## Parameter Types

#### Quantitative

- Conditional Parameter
- Constant Parameter
- Dependent Simulation Parameter
- Discrete Parameter
- Distribution Parameter
- Distribution Function Parameter
- Precomputed Parameter
- Qualitative Interpretation Parameter
- Random Bag Parameter
- Simulation Parameter

#### Qualitative

- Qualitative Parameter
- Qualitative Conditional Parameter
- Qualitative Random Bag Parameter

## License

I have intentionally chosen not to specify a license. If you wish to make use of this code, please reach out to me at tim.sullivan25@outlook.com to discuss the purpose of your project.
