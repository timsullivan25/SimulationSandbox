# SimulationSandbox

A class library that allows various types of simulations to be performed and connected through algebraic expressions.

## Overview

The original inspiration for this project came from the [Math.NET Symbolics](https://symbolics.mathdotnet.com/) computer algebra library. This library provides a way to evaluate formulas written in a standard format. For example, you can provide a string such as "1/(1 + a)", specify that the value of "a" is 5, and evaluate the string the obtain a result of ~0.167.

The purpose of my library is to extend this functionality by allowing the value of "a" to be generated using a variety of methods. The goal is to provide an easy, flexible way to simulate different types of events using the same building blocks. As long as the outcome can be expressed with an algebraic expression, it can be evaluated by generating values for the underlying parameters. Furthermore, simulations can also be used as parameters for other simulations, essentially allowing you to construct a system of equations to define complex problems.

## Simulation Types

- Standard Simulation
- Dependent Simulation
- Sensitivity Simulation
- Exhaustive Sensitivity Simulation
- Qualitative Simulation
- Binomial Tree Simulation
- Binomial Option Pricing Simulation

#### Standard Simulation

This serves as the building block for most other types of simulations. To create a simulation, you must provide an expression and a collection of parameters. For example:

    string expression = "twentysided";
    
    IParameter[] parameters = new IParameter[]
    {
        new DistributionParameter("twentysided", new DiscreteUniform(1, 20))
    };

  Simulation simulation = new Simulation(expression, parameters);

The above is a simple example of how expressions and parameters interact to create a simulation. The expression tells the simulation that we wish to evaluate the result of one variable named "twentysided". For every variable in the expression, we must define how the value of that variable will be determined. In this case, we have defined the "twentysided" variable to be a discrete uniform distribution from 1 to 20 -- essentially, we are going to roll a twenty-sided die and return the value.

Simulations can become far more complicated. Let's take a look at something that is a bit more useful:

    string expression = "Rf + B * (Rm - Rf)";
  
    IParameter[] parameters = new IParameter[]
    {
        new DistributionParameter("B", new Normal(1, 0.1)),
        new ConstantParameter("Rf", 0.02),
        new DistributionParameter("Rm", new Normal(0.08, 0.035))
    };
  
    Simulation simulation = new Simulation(expression, parameters);

The expression here represents the Capital Asset Pricing Model (CAPM). The inputs are the risk-free rate (Rm), Beta (B), and the expected market return (Rm). For this simulation, we have decided to hold our risk-free rate constant at 2% and fluctuate our Beta and market return using normal distributions. Presumably, we would do something like this if we were not sure what the exact values should be, but wanted to get an idea of what the range of expected returns looks like for our parameter estimates. A simulation like this would be run multiple times to generate a result set containing summary statistics such as min, max, mean, median, standard deviation, etc..

The types of parameters that can be used in a simulation will be detailed below. The test project also serves as a good example of how to create simulations and use the various parameters. However, I will highlight one more feature in this overview -- the ability to include simulations as parameters for other simulations. First, I will show how this is represented conceptually with expressions:

    x + y + z
    
    x = 10 * a + b
    y = (c - d) / 5
    z = ln(n^(1/2))

The ultimate expression we wish to evaluate is x + y + z. As shown by the full equations, x, y, and z are all stand-alone expressions that need to be evaluated in order to produce a value from our final expression. Instead of writing one complex expression, we can use multiple simulations to break it into pieces that can be evaluated indepedently. One thing that is not obvious from this example is that the return value produce by a simulation parameter does not have to be the number generated by evaluating of the formula, but can be a summary statistic instead. In this case, we could have defined a and b in equation x to be distribution parameters, run simulation x 100 times per evaluation of the main expression, and taken the maximum value from each set of 100 inner simulations. Perhaps I will replace this with a less arbitrary example in the future, but the point I am trying to convey is that being able to use simulations inside of simulations is useful both for breaking complex problems into smaller pieces and for providing enhanced functionality that would be difficult to replicate otherwise. This enhanced functionality will be shown in more detail in the sensitivity simulation section.

## Parameter Types

#### Quantitative

- Conditional Parameter
- Constant Parameter
- Dependent Simulation Parameter
- Discrete Parameter
- Distribution Parameter
- Distribution Function Parameter
- Precomputed Parameter
- Qualitative Interpretation Parameter
- Random Bag Parameter
- Simulation Parameter

#### Qualitative

- Qualitative Parameter
- Qualitative Conditional Parameter
- Qualitative Random Bag Parameter

## License

I have intentionally chosen not to specify a license. If you wish to make use of this code, please reach out to me at tim.sullivan25@outlook.com to discuss the purpose of your project.
